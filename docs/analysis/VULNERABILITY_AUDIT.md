# Vulnerability Audit (Agent Review)

Date: 2026-02-11
Scope reviewed: `server/` API and selected client integration points.

## High-risk findings

### 1) Unauthenticated SSRF in RSS validation endpoint
- **Where**: `POST /ingestion/validate` is public and accepts arbitrary `url` input.
- **Why this is risky**: the server performs outbound fetches to attacker-controlled URLs using `parser.parseURL(url)`. This can be abused for SSRF (internal service probing, metadata endpoint access, or unexpected egress).
- **Evidence**:
  - Route is not protected by `authMiddleware` in `server/api/routes/ingestion.ts`.
  - `validateRssFeed()` and `getFeedMetadata()` fetch any supplied URL in `server/services/rssFetcher.ts`.
- **Recommended remediation**:
  - Require auth on `/ingestion/validate`, or disable in production.
  - Enforce URL allowlists and block private/link-local CIDRs and non-HTTP(S) schemes.
  - Resolve DNS/IP before request and reject internal ranges.

### 2) Admin API key allowed via query parameter + logged in plaintext
- **Where**: `authMiddleware` reads API key from `req.query.apiKey`, and request logging serializes `req.query`.
- **Why this is risky**: query-string secrets are commonly leaked via access logs, reverse proxies, analytics, browser history, and Referer headers.
- **Evidence**:
  - `const apiKey = req.headers['x-api-key'] || req.query.apiKey;`
  - Request logger logs `query: req.query` for every request.
- **Recommended remediation**:
  - Accept admin key only via `x-api-key` (or `Authorization` bearer token).
  - Stop logging raw query objects, or redact secret-like keys (`apiKey`, `token`, `key`, etc.).

## Medium-risk findings

### 3) Overly permissive CORS policy on backend
- **Where**: API sets `Access-Control-Allow-Origin: *` globally.
- **Why this is risky**: broad cross-origin read access increases attack surface and can expose endpoints/data unintentionally to any web origin.
- **Evidence**:
  - Custom CORS middleware in `server/api/server.ts` hardcodes wildcard origin.
- **Recommended remediation**:
  - Restrict allowed origins by environment configuration.
  - Minimize allowed methods/headers and keep explicit list.

### 4) Missing input bounds on expensive embedding generation endpoint
- **Where**: `POST /ingestion/embeddings` reads unvalidated `limit` from request body.
- **Why this is risky**: authenticated misuse can set very large limits and cause costly CPU/API usage (resource exhaustion).
- **Evidence**:
  - `const limit = req.body.limit || 200;` without numeric validation/cap.
- **Recommended remediation**:
  - Validate with schema (`z.number().int().min(1).max(500)` etc.).
  - Add stricter route-level rate limiting and execution guards.

## Low-risk findings

### 5) Security headers baseline not enforced
- **Where**: Express app does not apply `helmet` (or equivalent).
- **Why this is risky**: missing baseline headers weakens browser-side protections.
- **Recommended remediation**:
  - Add `helmet()` with tuned policy for this API.

## Priority remediation plan
1. Patch SSRF on `/ingestion/validate` (auth + URL/IP restrictions).
2. Remove query-param API keys and redact sensitive query logging.
3. Lock down CORS to trusted origins.
4. Add `zod` validation/caps for ingestion limits.
5. Add `helmet` and review hardening defaults.

