<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PlacementsBridge - Connect Students with Internship Opportunities in Uganda</title>
    <meta name="description" content="Bridge to your future career. Connect Uganda's brightest students with leading companies for meaningful internship placements by region, industry, and field of study." />
  <meta name="author" content="CareerCompass-UG" />

  <meta property="og:title" content="CareerCompass-UG" />
  <meta property="og:description" content="Connect students in Uganda with internship and mentorship opportunities." />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="/assets/og-image.png" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="@CareerCompassUG" />
  <meta name="twitter:image" content="/assets/og-image.png" />
    <link rel="icon" href="/favicon.ico" />
  </head>

  <body>
    <div id="root"></div>
    <style>
      /* Hide Lovable elements via CSS */
      [data-lovable],
      [data-with-lovable],
      [class*="lovable"],
      [class*="edit-with-lovable"],
      iframe[src*="lovable"],
      script[src*="lovable"],
      div[id*="lovable"],
      button[aria-label*="lovable"],
      button[aria-label*="Edit with"],
      [data-testid*="lovable"] {
        display: none !important;
        visibility: hidden !important;
        pointer-events: none !important;
      }
    </style>
    <script>
      // Aggressively remove Lovable widgets and scripts
      const lovablePatterns = ['lovable', 'edit-with', 'floating-editor', 'tagger'];
      
      function removeAllLovable() {
        // Remove by class, id, data attributes
        document.querySelectorAll('[class*="lovable"], [id*="lovable"], [data-lovable], [data-with-lovable]').forEach(el => el.remove());
        
        // Remove buttons with "Edit with" text
        document.querySelectorAll('button, a, div').forEach(el => {
          if (el.textContent && el.textContent.includes('Edit with')) {
            el.remove();
          }
          // Check for Lovable in various attributes
          const attrs = el.attributes || [];
          for (let attr of attrs) {
            if (attr.value && lovablePatterns.some(p => attr.value.toLowerCase().includes(p))) {
              el.remove();
              break;
            }
          }
        });
        
        // Remove Lovable scripts
        document.querySelectorAll('script').forEach(el => {
          if (el.src && el.src.includes('lovable')) el.remove();
          if (el.textContent && el.textContent.includes('lovable')) el.remove();
        });
        
        // Remove Lovable iframes
        document.querySelectorAll('iframe').forEach(el => {
          if (el.src && el.src.includes('lovable')) el.remove();
        });
      }
      
      // Run multiple times to catch all injected content
      removeAllLovable();
      document.addEventListener('DOMContentLoaded', removeAllLovable);
      setTimeout(removeAllLovable, 100);
      setTimeout(removeAllLovable, 300);
      setTimeout(removeAllLovable, 500);
      setTimeout(removeAllLovable, 1000);
      setTimeout(removeAllLovable, 2000);
      
      // Use MutationObserver to continuously remove new Lovable elements
      const observer = new MutationObserver((mutations) => {
        mutations.forEach(mutation => {
          if (mutation.addedNodes.length) {
            setTimeout(removeAllLovable, 50);
          }
        });
      });
      
      observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: false
      });
    </script>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
